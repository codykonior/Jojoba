<#

.SYNOPSIS
Converts Jojoba test case objects to a jUnit XML file Jenkins can understand.

.DESCRIPTION
Jenkins is best used with a jUnit XML file to provide further information on why tests have passed, failed, or been skipped. This function provides that translation.

.PARAMETER Test
One or more Jojoba test case outputs. This would normally be generated by Start-Jojoba and sent here by Publish-Jojoba.

.PARAMETER OutputPath
Override the output path. It defaults to ".\Jojoba.xml".

.EXAMPLE
[PSCustomObject] @{
    Suite = "Suite"
    Timestamp = Get-Date
    Time = 0
    ClassName = "Test"
    Name = "Server1"
    Result = "Pass"
    ErrorMessage = New-Object Collections.ArrayList
    Data = New-Object Collections.ArrayList
} | Write-JojobaXml

#>

function Write-JojobaXml {
	[CmdletBinding()]
	param (
		[Parameter(Mandatory = $true, ValueFromPipeline=$true)]
		$Test,
		$OutputPath = ".\Jojoba.xml"
	)

    begin {
	    $xmlDocument = New-Object System.Xml.XmlDocument
	    $xmlDocument.LoadXml('<testsuites></testsuites>')

	    $templateSuite = New-Object System.Xml.XmlDocument
	    $templateSuite.LoadXml('<testsuite name="" tests="0"></testsuite>')
	    $templateCase = New-Object System.Xml.XmlDocument
	    $templateCase.LoadXml('<testcase classname="" name="" timestamp="" time="0"></testcase>')
	    $templateFailure = New-Object System.Xml.XmlDocument
	    $templateFailure.LoadXml('<failure message=""></failure>')
	    $templateSkipped = New-Object System.Xml.XmlDocument
	    $templateSkipped.LoadXml('<skipped message=""></skipped>')
    }

    process {
        foreach ($suite in ($Test | Group-Object Suite | Sort-Object Case)) {
            # This wouldn't normally be required but is to get around an edge
            # case of users running scripts instead of modules.
            $suiteName = [string] $Suite.Name
            if (!$suiteName) {
                $suiteName = "Jojoba"
            }
            $xmlSuite = $xmlDocument.ImportNode($templateSuite.testsuite, $false)
            $xmlSuite.name = [string] $suiteName
            $xmlSuite.tests = [string] $suite.Group.Count

            foreach ($case in $suite.Group) {
                $xmlCase = $xmlDocument.ImportNode($templateCase.testcase, $false)
                $xmlCase.timestamp = [string] $case.Timestamp
                $xmlCase.time = [string] $case.Time

                # Some of these ToString's don't seem necessary, but, it seems
                # in some cases the parameters are a NoteProperty and it really
                # demands they are exactly a string. Sometimes they're $null...
                $xmlCase.classname = [string] $suiteName + "." + $case.ClassName
                $xmlCase.name = [string] $case.Name

                if ($case.Result -eq "Fail") {
                    $xmlFailure = $xmlDocument.ImportNode($templateFailure.failure, $false)
                    if ($case.Message) {
                        $xmlFailure.message = [string] $case.Message
                    }
                    if ($case.Data) {
                        $xmlFailure.InnerText = [string] $case.Data
                    }

                    [void] $xmlCase.AppendChild($xmlFailure)
                } elseif ($case.Result -eq "Skip") {
                    $xmlSkipped = $xmlDocument.ImportNode($templateSkipped.skipped, $false)
                    if ($case.Message) {
                        $xmlSkipped.message = [string] $case.Message
                    }
                    if ($case.Data) {
                        $xmlSkipped.InnerText = [string] $case.Data
                    }

                    [void] $xmlCase.AppendChild($xmlSkipped)
                }
                [void] $xmlSuite.AppendChild($xmlCase)
            }

            [void] $xmlDocument.ChildNodes.AppendChild($xmlSuite)
        }
    }

    end {
    	$xmlDocument.Save($OutputPath)
    }
}

